import { ICoreProvider } from './ICoreProvider';

/**
 * Context for test generation and fixing
 */
export interface TestContext {
    sourceCode: string;
    fileName: string;
    /** Formatted string with all dependency file contents */
    dependencyContext?: string;
    errorContext?: string;
    /** The current test code (for fix attempts) */
    currentTestCode?: string;
    /** Hints about environment issues detected */
    environmentHints?: string;
    /** Dynamic system prompt (built from detected stack) */
    systemPrompt?: string;
    attempt?: number;
    maxAttempts?: number;
}

/**
 * Context for adversarial review
 */
export interface ReviewContext {
    sourceCode: string;
    testCode: string;
    fileName: string;
    systemPrompt?: string;
    userPrompt?: string;
}

/**
 * Result from adversarial review
 */
export interface ReviewResult {
    passed: boolean;
    score: number; // 0-10
    critique: string;
    suggestions: string[];
}

/**
 * Context for learning capture
 */
export interface LearningContext {
    sourceCode: string;
    originalTestCode: string;
    critique: string;
    fixedTestCode: string;
    fileName: string;
    systemPrompt?: string;
    userPrompt?: string;
}

/**
 * Structured learning entry for dataset improvements
 */
export interface LearningEntry {
    timestamp: string;
    fileName: string;
    sourceCode: string;
    originalTestCode: string;
    critique: string;
    fixedTestCode: string;
    improvementDelta: string;
    category: 'mocking' | 'logic' | 'edge-case' | 'spfx-context' | 'other';
}

/**
 * Result from LLM generation
 */
export interface LLMResult {
    code: string;
    model: string;
    tokensUsed?: number;
}

/**
 * Project analysis for LLM planning
 */
export interface ProjectAnalysis {
    packageJson: any;
    tsConfig?: any;
    existingJestConfig?: string;
    existingTests?: string[];
    dependencies: Record<string, string>;
    devDependencies: Record<string, string>;
    framework?: string;
    reactVersion?: string;
    nodeVersion?: string;
}

/**
 * Test strategy planned by LLM
 */
export interface TestStrategy {
    approach: 'unit' | 'integration' | 'component';
    mockingStrategy: 'minimal' | 'moderate' | 'extensive';
    mocksNeeded: string[];
    testStructure: string;
    expectedCoverage: number;
    potentialIssues: string[];
    estimatedIterations: number;
}

/**
 * Jest configuration generated by LLM
 */
export interface GeneratedJestConfig {
    configJs: string;
    setupJs: string;
    mocks: Record<string, string>;
    explanation: string;
}

/**
 * Batch generation plan from LLM
 */
export interface BatchGenerationPlan {
    groups: Array<{
        name: string;
        priority: number;
        files: string[];
        reason: string;
    }>;
    estimatedTime: string;
    recommendedConcurrency: number;
}

/**
 * Interface for LLM providers
 * Allows switching between different AI providers (Copilot, Azure OpenAI, etc.)
 * 
 * Extends ICoreProvider to maintain compatibility with new capability-based architecture
 * while preserving testing-specific functionality.
 */
export interface ILLMProvider extends ICoreProvider {
    /**
     * Generate a test file for the given source code
     */
    generateTest(context: TestContext): Promise<LLMResult>;

    /**
     * Fix a failing test based on error output
     */
    fixTest(context: TestContext): Promise<LLMResult>;

    /**
     * Perform an adversarial review of a generated test
     */
    reviewTest(context: ReviewContext): Promise<ReviewResult>;

    /**
     * Generate a structured learning entry summarizing an improvement
     */
    generateLearningEntry(context: LearningContext): Promise<LearningEntry>;

    /**
     * Detect missing dependencies based on package.json content
     * @param packageJsonContent - Full package.json object
     * @param previousAttempt - Optional info from previous failed attempt for retry
     */
    detectDependencies(
        packageJsonContent: any,
        previousAttempt?: { error: string; attemptNumber: number }
    ): Promise<Record<string, string>>;

    /**
     * Analyze an error (dependency, compilation, execution) and suggest a fix
     * Returns installation commands or configuration changes needed
     */
    analyzeAndFixError(error: string, projectContext: {
        packageJson: any;
        nodeVersion?: string;
        jestConfig?: string;
        errorType: 'dependency' | 'compilation' | 'execution';
    }): Promise<{
        diagnosis: string;
        packages?: string[];
        commands?: string[];
        configChanges?: Record<string, any>;
    }>;

    // ===== LLM-First Planning Methods =====

    /**
     * Analyze project and plan test generation strategy
     * LLM decides: mocking approach, test structure, potential issues
     */
    planTestStrategy(context: {
        sourceCode: string;
        fileName: string;
        projectAnalysis: ProjectAnalysis;
        existingTestPatterns?: string[];
    }): Promise<TestStrategy>;

    /**
     * Generate personalized Jest configuration for a project
     * LLM analyzes tsconfig, package.json, and generates custom config
     */
    generateJestConfig(context: {
        projectAnalysis: ProjectAnalysis;
        requirements: string[];
    }): Promise<GeneratedJestConfig>;

    /**
     * Plan batch test generation with prioritization
     * LLM decides: which files first, how to group them, estimated time
     */
    planBatchGeneration(context: {
        allFiles: string[];
        projectStructure: any;
        existingTests: string[];
        dependencies: Record<string, string[]>;
    }): Promise<BatchGenerationPlan>;

    /**
     * Validate if suggested package versions exist in npm registry
     * LLM checks and suggests alternatives if versions don't exist
     */
    validateAndFixVersions(context: {
        suggestedVersions: Record<string, string>;
        validationErrors: string[];
    }): Promise<Record<string, string>>;
}
